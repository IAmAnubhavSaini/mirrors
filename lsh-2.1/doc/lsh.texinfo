\input texinfo          @c -*-texinfo-*-

@c %**start of header
@setfilename lsh.info
@settitle lsh
@c %**end of header

@documentencoding ISO-8859-1

@dircategory GNU Packages
@direntry
* LSH: (lsh).           Secure Shell and related utilities.
@end direntry

@set UPDATED-FOR 2.0

@c Latin-1 doesn't work with tex output.
@c Also look out for é characters.

@set AUTHOR Niels Möller
@ifinfo
Draft manual for LSH. This manual corresponds to @command{lsh} version
@value{UPDATED-FOR}. 

Copyright 2000, 2004 @value{AUTHOR}

Permission is granted to make and distribute verbatim
copies of this manual provided the copyright notice and
this permission notice are preserved on all copies.

@ignore
Permission is granted to process this file through TeX
and print the results, provided the printed document
carries a copying permission notice identical to this
one except for the removal of this paragraph (this
paragraph not being relevant to the printed manual).

@end ignore
Permission is granted to copy and distribute modified
versions of this manual under the conditions for
verbatim copying, provided also that the sections
entitled ``Copying'' and ``GNU General Public License''
are included exactly as in the original, and provided
that the entire resulting derived work is distributed
under the terms of a permission notice identical to this
one.

Permission is granted to copy and distribute
translations of this manual into another language,
under the above conditions for modified versions,
except that this permission notice may be stated in a
translation approved by the Free Software Foundation.

@end ifinfo

@titlepage
@sp 10
@c @center @titlefont{LSH Manual}

@title LSH Manual
@subtitle For @command{lsh} version @value{UPDATED-FOR}

@author @value{AUTHOR}

@c The following two commands start the copyright page.
@page
@vskip 0pt plus 1filll
Copyright @copyright{} 2000, 2004 @value{AUTHOR}

Permission is granted to make and distribute verbatim
copies of this manual provided the copyright notice and
this permission notice are preserved on all copies.

Permission is granted to copy and distribute modified
versions of this manual under the conditions for
verbatim copying, provided also that the sections
entitled ``Copying'' and ``GNU General Public License''
are included exactly as in the original, and provided
that the entire resulting derived work is distributed
under the terms of a permission notice identical to this
one.

Permission is granted to copy and distribute
translations of this manual into another language,
under the above conditions for modified versions,
except that this permission notice may be stated in a
translation approved by the Free Software Foundation.

@end titlepage

@contents

@ifnottex
@node     Top, Introduction, (dir), (dir)
@comment  node-name,  next,  previous,  up
@ifinfo
@top
@end ifinfo

This document describes @command{lsh} and related programs. The
@command{lsh} suite of programs is intended as a free replacement for
the @command{ssh} suite of programs. In turn, @command{ssh} was intended
as a secure replacement for the @command{rsh} and @command{rlogin}
programs for remote login over the Internet.

@command{lsh} is a component of the @acronym{GNU} system.

This manual explains how to use and hack @command{lsh}; it corresponds to
@command{lsh} version @value{UPDATED-FOR}.

@menu
* Introduction::                
* Installation::                
* Getting started::             
* Invoking lsh::                
* Invoking lshg::                
* Invoking lshd::               
* Files and environment variables::  
* Terminology::                 
* Concept Index::               

@detailmenu
 --- The Detailed Node Listing ---

Introduction

* Threats::                     
* Features::                    
* Related techniques::          

Related programs and techniques

* ssh1::                        SSH version 1
* ssh2::                        SSH version 2
* Kerberos::                    Kerberos
* ipsec::                       IP Sec

Getting started

* lsh-make-seed::               Initializing the randomness generator
* lsh basics::                  Connection with lsh
* tcpip forwarding::            Forwarding @acronym{TCP/IP} ports
* lshd basics::                 Starting the lshd deamon
* public-key::                  Using public-keys
* srp::                         Using SRP authentication
* sexp::                        Examining keys and other S-exp files
* Converting keys::             

Invoking @command{lsh}

* Algorithms: Algorithm options.  Selecting algorithms.
* Hostauth options::            
* Userauth options::            
* Actions: Action options.      What to do after login.
* Messages: Verbosity options.  Tuning the amount of messages.

@end detailmenu
@end menu

@end ifnottex

@node Introduction, Installation, Top, Top
@comment  node-name,  next,  previous,  up
@chapter Introduction

What is this thing called computer security anyway? Why would you want
to use a program like @command{lsh}?

This chapter explains the threats @command{lsh} tries to protect you from,
and some of the threats that remain. It also describes some of the
technologies used in @command{lsh}.

From time to time in this manual, I will speak about the @dfn{enemy}.
This means anybody who is trying to eavesdrop or disturb your private
communication. This usage is technical, and it does not imply that the
enemy is somehow morally inferior to you: The enemy may be some awful
criminals trying to eavesdrop on you, or it may be the police trying to
eavesdrop on the same criminals.

The enemy can be a criminal, or a competitor, or your boss who's trying
to find out how much you tell collegues at competing firms. It may be
your own or somebody else's national security officials. Or your
ex-boyfriend who happens to be too curious.

So what can the enemy do to your communications and your privacy?
Remember that just because you're paranoid that doesn't mean that nobody
is trying to get you@dots{}


@menu
* Threats::                     
* Features::                    
* Related techniques::          
@end menu

@node Threats, Features, Introduction, Introduction
@comment  node-name,  next,  previous,  up
@section Threats

When logging in to some other machine via the Internet, either in the
same building or a few continents away, there are several things that
may be under enemy attack.

@table @dfn
@item Local attacks
The enemy controls your local environment. He or she may be looking over
your shoulder. Your local machine might be cracked. Or there may be some
device planted inside your keyboard transmitting everything you type to
the attacker. About the same problems occur if the attacker has taken
control over your target machine, i.e. the remote machine you have
logged in to.

@item Denial-of-service attacks
The enemy has cut your network cable, effectively stopping your
communication. Even without doing physical damage, the enemy may be able
to flood and overload computers or network equipment. Or disrupt network
traffic by sending fake packets to hangup your @acronym{TCP/IP}
connections.

@item Passive eavesdropping
The enemy may be able to listen to your communication somewhere along
its path. With the global Internet, it's difficult to predict who might
be able to listen. Internet traffic between buildings just a few hundred
meters apart have been observed temporarily being routed through half a
dozen countries, perhaps a few thousand kilometers.

And even without routing anomalies, it is possible that the enemy has
been able to take control of some nearby machine, and can listen in from
there. Of course, passive eavesdropping is most dangerous if you
transmit cleartext passwords. This is the main reason not to use vanilla
telnet to login to remote systems. Use a telnet with support for
@acronym{SSL} or Kerberos, or use a program like @command{lsh} or
@command{ssh}. 

A passive eavesdropper is assumed not to do anything nasty with your
packets beyond listening to them.

@item Name resolution attacks
The translation from symbolic @acronym{DNS} names to numeric
ip-addresses may be controlled by the attacker. In this case, you may
think that you are connecting to a friendly machine, when in fact you
are connecting somewhere else.

@item Fake packets
It is fairly easy to fake the source address of an @acronym{IP}-packet,
although it is more difficult to get hold on the replies to the faked
packets. But even without any replies, this can cause serious
problems. 

@item Man-in-the-middle attack
In this attack, the enemy sits between you and the target. When
communicating with you, he pretends to be the target. When communicating
with the target, he pretends to be you. He also passes all information
on more or less unmodified, so that he is invisible to you and the
target. To mount this attack, the enemy either needs physical access to
some network equipment on the path between you and the target, or he has
been able to fool you to connect to him rather than to the target, for
example by manipulating the @acronym{DNS}-system.

@end table

@command{lsh} makes no attempt to protect you from local attacks. You have
to trust the endpoint machines. It seems really difficult to uphold any
security if the local machine is compromised. This is important to keep
in mind in the ``visitor''-scenario, where you visit a friend or perhaps an
Internet café and want to connect to some of the machines at home or at
work. If the enemy has been able to compromize your friend's or the
café's equipment, you may well be in trouble.

Protection from denial-of-service attacks is also a very difficult
problem, and @command{lsh} makes no attempt to protect you from that.

Instead, the aim of @command{lsh}, and most serious tools for cryptographic
protection of communications across the net, is to isolate the
vulnerabilities to the communication endpoints. If you know that the
endpoints are safe, the enemy should not be able to compromize your
privacy or communications. Except for denial-of-service attacks (which
at least can't be performed without you noticing it).

First of all, @command{lsh} provides protection against passive
eavesdropping. In addition, if you take the appropriate steps to make
sure that hostkeys are properly authenticated, @command{lsh} also protects
against man-in-the-middle attacks and in particular against attacks on
the name resolution. In short, you need only trust the security at the
end points: Even if the enemy controls all other network equipment, name
resolution and routing infrastructure, etc, he can't do anything beyond
the denial-of-service attack.

And at last, remember that there is no such thing as absolute security.
You have to estimate the value of that which you are protecting, and
adjust the security measures so that your enemies will not find it worth
the effort to break them.


@node Features, Related techniques, Threats, Introduction
@comment  node-name,  next,  previous,  up
@section Features

@command{lsh} does not only provide more secure replacements for
@command{telnet}, @command{rsh} and @command{rlogin}, it also provides
some other features to make it convenient to communicate securely. This
section is expected to grow with time, as more features from the
wish-list are added to lsh. One goal for @command{lsh} is to make it
reasonable easy to extend it, without messing with the core security
functionality.

@command{lsh} can also be used in something called gateway mode, in
which you can authenticate once and set up a connection that can
later be used for quickly setting up new sessions with @command{lshg} 
(@pxref{Invoking lshg}).

@command{lsh} can be configured to allow login based on a personal
key-pair consisting of a private and a public key, so that you can
execute remote commands without typing your password every time. There
is also experimental support for Thomas Wu's Secure Remote Password
Protocol (@acronym{SRP}). Kerberos support is on the wish list but not
yet supported (@pxref{Kerberos}).

The public-key authentication methods should also be extended to support
Simple Public Key Infrastructure (@acronym{SPKI}) certificates,
including some mechanism to delegate restricted logins.

Forwarding of arbitrary @acronym{TCP/IP} connections is provided. This
is useful for tunneling otherwise insecure protocols, like telnet and
pop, through an encrypted @command{lsh} connection.

@command{lsh} also features a @acronym{SOCKS}-proxy which also
provides tunneling of @acronym{TCP/IP} connections, but can be easily
used, e.g.  from within popular web browsers like Mozilla and Firefox
for tunneling web traffic. There are also programs like
@command{tsocks} that performs transparent redirection of network
access through a @acronym{SOCKS} proxy.

Convenient tunneling of @acronym{X} was one of the most impressive
features of the original @command{ssh} programs. Both @command{lsh} and
@command{lshd} support @acronym{X}-forwarding, although @command{lshg}
does not.

Whan @acronym{X} forwarding is in effect, the remote process is started
in an environment where the @env{DISPLAY} variable in the environment
points to a fake @acronym{X} server, connections to which are forwarded
to the @acronym{X} server in your local environment. @command{lsh} also
creates a new ``fake'' @samp{MIT-MAGIC-COOKIE-1} for controlling access
control. Your real @acronym{X} authentication data is never sent to the
remote machine.

Other kinds of tunneling that may turn out to be useful include
authentication (i.e. @command{ssh-agent}), general forwarding of
@acronym{UDP}, and why not also general @acronym{IP}-tunneling.


@node Related techniques,  , Features, Introduction
@comment  node-name,  next,  previous,  up
@section Related programs and techniques

This sections describes some other programs and techniques related to
@command{lsh}. The ssh family of programs use mostly the same kind of
security as @command{lsh}. Kerberos and @acronym{IPSEC} operate quite
differently, in particular when it comes to protection against
man-in-the-middle attacks.

@menu
* ssh1::                        SSH version 1
* ssh2::                        SSH version 2
* Kerberos::                    Kerberos
* ipsec::                       IP Sec
@end menu

@node ssh1, ssh2, Related techniques, Related techniques
@comment  node-name,  next,  previous,  up
@subsection @code{ssh-1.x}

The first of the Secure shell programs was Tatu Ylönen's @command{ssh}.
The latest of the version 1 series is @code{ssh-1.33} which speaks
version 1.5 of the protocol. The ``free'' version of @code{ssh-1.33}
does not allow commercial use without additional licensing, which makes
@code{ssh-1.33} non-free software according to Debian's Free Software
Guidelines and the Open Source Definition.

The version 1 protocol has some subtle weaknesses, in particular, all
support for using stream ciphers was disabled by default a few versions
back, for security reasons.

There also exists free implementations of @code{ssh-1}, for both Unix
and Windows. @command{ossh} and later OpenSSH are derived from earlier
version av Tatu Ylönen's @command{ssh}, and are free software.

@node ssh2, Kerberos, ssh1, Related techniques
@comment  node-name,  next,  previous,  up
@subsection @code{ssh-2.x}

@command{ssh2} implements the next generation of the Secure Shell
protocol, the development of which is supervised by the @acronym{IETF}
secsh Working Group. Besides @command{lsh}, some well known
implementations of this protocol includes
@itemize
@item
OpenSSH (which supports version 2 of the protocol since May 2000).

@item
The @command{ssh2} series of proprietary programs sold by the SSH
company. @command{lsh} interoperates with current versions of these
programs, but not with version 3.0 and earlier (the older versions get
some details of the protocol wrong, probably because it predates the
protocol specification). The license for the SSH company's
@command{ssh2} programs is similar to that for recent versions of
@command{ssh1}, but with a narrower definition of ``non-commercial
use''.

@item
@command{putty}, a free @command{ssh} implementation for Microsoft
Windows.

@end itemize

There a numerous other implementations, both free and proprietary. The
above list is far from complete.


@node Kerberos, ipsec, ssh2, Related techniques
@comment  node-name,  next,  previous,  up
@subsection Kerberos

Kerberos is a key distribution system originally developed in the late
1980:s as a part of Project Athena at @acronym{MIT}. Recent development
have been done at The Royal Institute of Technology, Stockholm
(@acronym{KTH}).

Kerberos uses a central trusted ticket-granting server, and requires
less trust on the local machines in the system. It does not use
public-key technology.

Usually, Kerberos support is compiled into applications such as telnet,
ftp and X-clients. The ssh family of programs, on the other hand, tries
to do all needed magic, for instance to forward @acronym{X} securely,
and then provides general @acronym{TCP/IP} forwarding as a kitchen sink.

I believe Kerberos' and lsh's protection against passive eavesdropping
are mostly equivalent. The difference is in the set of machines and
assumptions you have to trust in order to be safe from a
man-in-the-middle attack.

I think the main advantage of @command{lsh} over Kerberos is that it is
easier to install and use for on ordinary mortal user. In order to set
up key exchange between two different Kerberos systems (or @dfn{Kerberos
realms}), the respective system operators need to exchange keys. In the
case of two random users at two random sites, setting up @command{lsh} or
some other program in the ssh family is likely easier than to get the
operators to spend time and attention. So @command{lsh} should be easier to
use in an anarchistic grass-roots environment.

Another perspective is to combine ssh features like @acronym{X} and
@acronym{TCP/IP} forwarding with authentication based on Kerberos. Such
an arrangement may provide the best of two worlds for those who happen
to have an account at a suitable ticket-granting server.

@node ipsec,  , Kerberos, Related techniques
@comment  node-name,  next,  previous,  up
@subsection @acronym{IPSEC}

@acronym{IPSEC} is a set of protocols for protecting general
@acronym{IP} traffic. It is developed by another @acronym{IETF} working
group, and is also a required part of @acronym{IP} version 6.

Again, the main difference between @acronym{IPSEC}, Kerberos and ssh
is the set of machines that have to be secure and the keys that have to
be exchanged in order to avoid man-in-the-middle attacks.

Current protocols and implementations of @acronym{IPSEC} only provide
authentication of machines; there's nothing analogous to the user
authentication in ssh or Kerberos.

On the other hand, @acronym{IPSEC} provides one distinct advantage over
application level encryption. Because @acronym{IP} and @acronym{TCP}
headers are authenticated, it provides protection against some
denial-of-service attacks. In particular, it makes attacks that cause
hangup of a @acronym{TCP} connection considerably more difficult.

So it makes sense to use both @acronym{IPSEC} and some application
level cryptographic protocol.

Also note that it is possible to use the @dfn{Point-to-Point Protocol}
(@acronym{PPP}) to tunnel arbitrary @acronym{IP} traffic accross an ssh
connection. This arrangement provides some of the functionality of
@acronym{IPSEC}, and is sometimes referred to as ``a poor man's Virtual
Private Network''.

@node Installation, Getting started, Introduction, Top
@comment  node-name,  next,  previous,  up
@chapter Installation

You install @command{lsh} with the usual @code{./configure && make &&
make install}. For a full listing of the options you can give to
@command{configure}, use @code{./configure --help}. For example, use
@option{--without-pty} to disable pty-support.

The most commonly used option is @option{--prefix}, which tells
configure where lsh should be installed. Default prefix is
@file{/usr/local}. The @command{lshd} server is installed in
@file{$prefix/sbin}, all other programs and scripts are installed in
@file{$prefix/bin}. 

The configure script tries to figure out if the linker needs any special
flags specifying where to find dynamically linked libraries at run time
(one case where this matters is if you have a dynamic libz.so installed
in a non-standard place). Usually, you can use

@example
./configure --with-lib-path=/opt/lib:/other/place
@end example

@noindent
to specify extra library directories, and the configure script should do
the right thing. If this doesn't work, or you believe that you know your
system better than @command{./configure}, just set LDFLAGS and/or
LD_LIBRARY_PATH to the right values instead.


@node Getting started, Invoking lsh, Installation, Top
@comment  node-name,  next,  previous,  up
@chapter Getting started
This section tells you how to perform some common tasks using the
@command{lsh} suite of programs, without covering all options and
possibilities.

@menu
* lsh-make-seed::               Initializing the randomness generator
* lsh basics::                  Connection with lsh
* tcpip forwarding::            Forwarding @acronym{TCP/IP} ports
* lshd basics::                 Starting the lshd deamon
* public-key::                  Using public-keys
* srp::                         Using SRP authentication
* sexp::                        Examining keys and other S-exp files
* Converting keys::             
@end menu

@node lsh-make-seed , lsh basics, Getting started, Getting started
@comment  node-name,  next,  previous,  up
@section Initializing the randomness generator

Several of the lsh programs requires a good pseudorandomness generator
for secure operation. The first thing you need to do is to create a
seed file for the generator. To create a personal seed file, stored as
@file{~/.lsh/yarrow-seed-file}, run

@example
lsh-make-seed
@end example

To create a seed file for use by @command{lshd}, run

@example
lsh-make-seed --server
@end example

as root. The seed file is stored as
@file{/var/spool/lsh/yarrow-seed-file}.


@node lsh basics, tcpip forwarding, lsh-make-seed , Getting started
@comment  node-name,  next,  previous,  up
@section @command{lsh} basics

@command{lsh} is the program you use for connection to a remote machine. A
few examples are:

@example
lsh sara.lysator.liu.se
@end example

@noindent
Connects to @samp{sara.lysator.liu.se} and starts an interactive shell.
In this example, and in the rest of the examples in this section, lsh
will ask for your password, unless you have public-key user
authentication set up.

The first time you try to connect to a new machine, @command{lsh}
typically complains about an ``unknown host key''. This is because it
has no reason to believe that it was the right machine that answered,
and not a machine controlled by the enemy (@pxref{Threats}). The default
behaviour is to never ever accept a server that is not properly
authenticated. A machine is considered authentic if it follows the
protocol and has an acl-entry for its public hostkey listed in
@file{~/.lsh/host-acls}.

To make lsh less paranoid, use

@example
lsh --sloppy-host-authentication sara.lysator.liu.se
@end example

@noindent
Then @command{lsh} will display a @dfn{fingerprint} of the host key of
the remote machine, and ask you if it is correct. If so, the machine is
considered authentic and a corresponding acl-entry is appended to the
file @file{~/.lsh/captured_keys}. You can copy acl-entries you have
verified to @file{~/.lsh/host-acls}.

You can even use

@example
lsh --sloppy-host-authentication --capture-to ~/.lsh/host-acls
@end example

@noindent
to get @command{lsh} to behave more like the traditional @command{ssh}
program. 

@c You can create fingerprints for the hostkeys you need regularly, and
@c keep with you (@pxref{sexp}).

@example
lsh -l omar sara.lysator.liu.se
@end example

@noindent
Connects, like above, but tries to log in as the user ``omar''.

@example
lsh sara.lysator.liu.se tar cf - some/dir | (cd /target/dir && tar -xf -)
@end example

Copies a directory from the remote machine, by executing one remote and
one local @command{tar} process and piping them together.

@example
CVS_RSH=lsh cvs -d cvs.lysator.liu.se:/cvsroot/lsh co lsh
@end example

@noindent
Checks out the @command{lsh} source code from the @acronym{CVS}
repository.

@example
lsh -G -B sara.lysator.liu.se
@end example

Opens an ssh connection, creates a ``gateway socket'', and forks into
the background. 

@example
lshg sara.lysator.liu.se
@end example

creates a new session using an existing gateway socket, without the
overhead for a new key exchange and without asking for any passwords.

@node  tcpip forwarding, lshd basics, lsh basics, Getting started
@comment  node-name,  next,  previous,  up
@section Port forwarding

One useful feature of @command{lsh} and other ssh-like programs is the
ability to forward arbitrary connections inside the encrypted
connection. There are two flavors: ``local'' and ``remote'' forwarding.

An example of local forwarding is

@example
lsh -L 4000:kom.lysator.liu.se:4894 sara.lysator.liu.se
@end example

@noindent
This makes @command{lsh} listen on port 4000 on the @emph{local}
machine. When someone connects, @command{lsh} asks the server to open a
connection from the @emph{remote} machine (i.e. @samp{sara}) to port
4894 on another machine (i.e. @samp{kom}). The two connections are piped
together using an encrypted channel.

There are a few things that should be noted here:

@itemize @bullet
@item
By default, @command{lsh} only listens on the loopback interface, so only
clients on the same machine can use the tunnel. To listen on all
interfaces, use the @option{-g} flag.

@item
A connection through the tunnel consists of three parts:

@enumerate
@item
From a client socket to the local port (4000 in this example) that
@command{lsh} listens on.

@item
The tunnel itself, from the local machine to the tunnel endpoint,
which is @samp{sara} in this example.

@item
The connection from the tunnel endpoint to the ultimate target, in this
example from @samp{sara} to @samp{kom}.

@end enumerate

Only the middle part is protected by @command{lsh}: all data flowing
through the tunnel is sent across the first and last part @emph{in the
clear}. So forwarding doesn't offer much protection unless the tunnel
endpoint and the ultimate target machine are close to each other. They
should usually be either the same machine, or two machines connected by
a local network that is trusted.

@item
Port forwarding is very useful for traversing firewalls. Of course, you
don't need to use lsh-style forwarding just to get out, there are other
tools like HTTPTunnel for that. But @command{lsh} helps you get out
through the firewall in a secure way.

@item
Port forwarding is done in addition to anything else @command{lsh} is
doing. In the example above, a tunnel is set up, but @command{lsh} will
also start an interactive shell for you. Just as if the @option{-L}
option was not present. If this is not what you want, the @option{-N} or
@option{-B} option is for you (@pxref{Invoking lsh})
@end itemize

Remote forwarding is similar, but asks the @emph{remote} machine to
listen on a port. An example of remote forwarding is

@example
lsh -g -R 8080:localhost:80 sara.lysator.liu.se
@end example

@noindent
This asks the remote machine to listen on port 8080 (note that you are
probably not authorized to listen on port 80). Whenever someone
connects, the connection is tunnelled to your local machine, and
directed to port 80 on the same machine. Note the use of @option{-g};
the effect is to allow anybody in the world to use the tunnel to connect
to your local webserver.

The same considerations that apply to forwarded local ports apply also to
forwarded remote ports.

At last, you can use any number of @option{-L} and @option{-R} options
on the same command line.


@node lshd basics, public-key, tcpip forwarding, Getting started
@comment  node-name,  next,  previous,  up
@section @command{lshd} basics
There are no global configuration files for @command{lshd}; all
configuration is done with command line options (@pxref{Invoking lshd}).

To run @command{lshd}, you must first create a hostkey, usually stored in
@file{/etc/lsh_host_key}. To do this, run

@example
lsh-keygen --server | lsh-writekey --server
@end example

@noindent
This will also create a file @file{/etc/lsh_host_key.pub},
containing the corresponding public key. 

A typical command line for starting lshd in daemon mode is simply

@example
lshd --daemonic
@end example

You can find init script for @command{lshd} tailored for Debian's and
RedHat's GNU/Linux systems in the @file{contrib} directory. 

It is also possible to let @command{init} start @command{lshd}, by
adding it in @file{/etc/inittab}.


@node public-key, srp, lshd basics, Getting started
@comment  node-name,  next,  previous,  up
@section Using public-key user authentication

Public-key user authentication is a way to authenticate for login,
without having to type any passwords. There are two steps: Creating a
key pair, and authorizing the public key to the systems where you want
to log in.

To create a keypair, run

@example
lsh-keygen | lsh-writekey
@end example

@noindent
This can take some time, but in the end it creates two files
@file{~/.lsh/identity} and @file{~/.lsh/identity.pub}.

If you want to use the key to login to some other machine, say
@samp{sara}, you can do that by first copying the key,

@example
lsh sara.lysator.liu.se '>my-key.pub' < ~/.lsh/identity.pub
@end example

@noindent
then authorizing it by executing, on @samp{sara},

@example
lsh-authorize my-key.pub
@end example

By default, @command{lsh-writekey} encrypts the private key using a
passphrase. This gives you some protection if a backup tape gets into
the wrong hands, or you use NFS to access the key file in your home
directory. If you want an unencrypted key, pass the flag @option{-c
none} to @command{lsh-writekey}.

For security reasons, you should keep the private key
@file{~/.lsh/identity} secret. This is of course particularly important
if the key is unencrypted; in that case, anybody who can read the file
will be able to login in your name to any machine where the
corresponding public key is registered as an authorized key.

Naturally, you should also make sure not to authorize any keys but your
own. For instance, it is inappropriate to use an insecure mechanism such
as unauthenticated email, @code{ftp} or @code{http} to transfer your
public key to the machines where you want to authorize it.

If you have accounts on several systems, you usually create one keypair
on each of the systems, and on each system you authorize some or all of
your other public keys for login.


@node srp, sexp, public-key, Getting started
@comment  node-name,  next,  previous,  up
@section Using @acronym{SRP} authentication

The Secure Remote Password protocol is a fairly new protocol that
provides mutual authentication based on a password. To use it, you must
first choose a secret password. Next, you create a @dfn{password
verifier} that is derived from the password. The verifier is stored on
the target machine (i.e. the machine you want to log in to).

To create a verifier, you run the @command{srp-gen} program and type
your new password. You have to do it on either the target machine,
redirecting the output to ~/.lsh/srp-verifier, or you can generate it on
some other machine and copy it to the target.

The main advantage of using @acronym{SRP} is that you use the password
not only to get access to the remote machine, but you also use it to
authenticate the remote machine. I.e. you can use it to connect
securely, @emph{without} having to know any hostkeys or fingerprints
beforehand!

For instance, you could connect using @acronym{SRP} to fetch the hostkey
fingerprint for the remote machine, as a kind of bootstrapping
procedure, and then use traditional authentication methods for further
connections.

For this to work, the verifier @emph{must} be kept @emph{secret}. If the
enemy gets your verifier, he can mount some attacks:

@itemize @bullet
@item
He can mount a @dfn{dictionary attack} on your password, i.e. generate a
large list of likely password and check if any of them matches yours.

@item
He can impersonate the server. That means that if you try to connect to
the remote machine using @acronym{SRP}, and the attacker can intercept
your connection (e.g. by attacking the name resolution or routing
system) he can successfully pretend to be the real server.
@end itemize

If you use @acronym{SRP} to get the hostkey or fingerprint for the
remote machine, as outlined above, the impersonation attack destroys
security, you could just as well connect the hostkey presented by the
remote server without verifying it at all.

If you use @acronym{SRP} exclusively, the situation seems somewhat
different. As far as I can see, an attacker knowing your verifier can
not mount a traditional man-in-the-middle-attack: He can play the
server's part when talking to you, but in order to play your part when
talking to the real server, he needs to know your password as well.

@acronym{SRP} support is disabled by default, but can be enabled by the
@option{--srp-keyexchange} option to @command{lshd} and @command{lsh}
(naturally, it won't be used unless enabled on both sides). At the time
of this writing, @acronym{SRP} is too new to be trusted by conservative
cryptographers (and remember that conservatism is a virtue when it comes
to security).

And even if @acronym{SRP} in itself is secure, the way @command{lsh}
integrates it into the @code{ssh} protocol has not had much peer review.
The bottom line of this disclaimer is that the @acronym{SRP} support in
@command{lsh} should be considered experimental.

As far as I know, using @acronym{SRP} as a host authentication mechanism
is not supported by any other @code{ssh} implementation. The protocol
@command{lsh} uses is described in the @file{doc/srp-spec.txt}.
Implementations that use @acronym{SRP} only as a user authentication
mechanism are not compatible with @command{lsh}.

@node sexp, Converting keys, srp, Getting started
@comment  node-name,  next,  previous,  up
@section Examining keys and other sexp files

Keys and most other objects @command{lsh} needs to store on disk are
represented as so called S-expressions or @dfn{sexps} for short.
S-expressions have their roots in the Lisp world, and a variant of them
in used in the Simple Public Key Infrastructure (@acronym{SPKI}).
Currently, @command{lsh}'s support for @acronym{SPKI} is quite limited,
but it uses @acronym{SPKI}'s formats for keys and Access Control Lists
(@acronym{ACL}:s).

There are several flavours of the sexp syntax:

@itemize @bullet
@item
The canonical syntax is somewhere between a text and a binary format,
and is extremely easy for programs to read and write.

@item
The transport syntax, which is suitable when embedding sexps in text
files. It is essentially the canonical representation, encoded using
base64.

@item
The advanced syntax, which is intended for humans to read and write, and
bears some resemblance to Lisp expressions.
@end itemize

To see what your @file{~/.lsh/identity.pub} file really contains, try

@example
sexp-conv < ~/.lsh/identity.pub
@end example

The @command{sexp-conv} program can also be used to computes
fingerprints. The fingerprint of a key (or any sexp, for that matter) is
simply the hash of its canonical representation. For example,

@example
sexp-conv --hash </etc/lsh_host_key.pub
@end example

This flavour of fingerprints is different from the ssh
fingerprint convention, which is based on a hash of the key expressed in
ssh wire format. To produce ssh standard fingerprints, use
@samp{lsh-export-key --fingerprint}.

@node  Converting keys,  , sexp, Getting started
@comment  node-name,  next,  previous,  up
@section Converting keys from @command{ssh2} and OpenSSH

If you are already using @command{ssh2} or OpenSSH, and have created one
or more personal keypairs, you need to convert the public keys to
@command{lsh}'s format before you can authorize them. Use the supplied
@command{ssh-conv} script,

@example
ssh-conv <openssh-key.pub >new-key.pub
@end example

You can then use the usual @command{lsh-authorize} on the converted
keys. @command{ssh-conv} supports both @acronym{DSA} and @command{RSA} keys.

Conversion of keys the other way is also possible, by using the
@command{lsh-export-key} program. It reads a public key in
the  @acronym{SPKI} format used by @command{lsh} on stdin, and writes the key in
@command{ssh2}/OpenSSH format on stdout.

If you want to use your @command{lsh} key to log in to another system
running and OpenSSH server, you can do like this:
 
@example
lsh-export-key --openssh < .lsh/identity.pub >sshkey

@end example

And on the other machine, after having somehow copied the sshkey
file, just add it to the end of your @file{authorized_keys} file:

@example
cat sshkey >> ~/.ssh/authorized_keys
@end example


@command{lsh-export-key} can also be used to check the fingerprint of
keys (just like @command{ssh-keygen}).

@example
lsh-export-key --fingerprint < /etc/lsh_host_key.pub
@end example

show the @acronym{MD5} and Bubble babble 
fingerprint of the server public key.


There are currently no tools for converting private keys.


@node Invoking lsh, Invoking lshg, Getting started, Top
@comment  node-name,  next,  previous,  up
@chapter Invoking @command{lsh}
@anchor{lsh-usage}

You use @command{lsh} to login to a remote machine. Basic usage is

@samp{lsh [-p @var{port number}] sara.lysator.liu.se}

which attempts to connect, login, and start an interactive shell on the
remote machine. Default @var{port number} is whatever your system's
@file{/etc/services} lists for @command{ssh}. Usually, that is port 22.

There is a plethora of options to @command{lsh}, to let you configure where
and how to connect, how to authenticate, and what you want to do once
properly logged in to the remote host. Many options have both long and
short forms. This manual does not list all variants; for a full listing
of supported options, use @samp{lsh --help}.

Note that for many of the options to @command{lsh}, the ordering of the
options on the command line is important.

@c FIXME: Say something about the escape char mechanism here
@menu
* Algorithms: Algorithm options.  Selecting algorithms.
* Hostauth options::            
* Userauth options::            
* Actions: Action options.      What to do after login.
* Messages: Verbosity options.  Tuning the amount of messages.
@end menu

@node Algorithm options, Hostauth options, Invoking lsh, Invoking lsh
@comment  node-name,  next,  previous,  up
@section Algorithm options

Before a packet is sent, each packet can be compressed, authenticated,
and encrypted, in that order. When the packet is received, it is first
decrypted, next it is checked that it is authenticated properly, and
finally it is decompressed. The algorithms used for this are negotiated
with the peer at the other end of the connection, as a part of the
initial handshake and key exchange.

Each party provides a list of supported algorithms, and the first
algorithm listed by the client, which is also found on the server's
list, is selected. Note that this implies that order in which algorithms
are listed on the server's list doesn't matter: if several algorithms
are present on both the server's and the client's lists, it's the
client's order that determines which algorithm is selected.

Algorithms of different types, e.g. data compression and message
authentication, are negotiated independently. Furthermore, algorithms
used for transmission from the client to the server are independent of
the algorithms used for transmission from the server to the client.
There are therefore no less than six different lists that could be
configured at each end.

The command line options for lsh and lshd don't let you specify
arbitrary lists. For instance, you can't specify different preferences
for sending and receiving.

There is a set of default algorithm preferences. When you use a command
line option to say that you want to use @var{algorithm} for one of the
algorithms, the default list is replaced with a list containing the
single element @var{algorithm}. For example, if you use @option{-c
arcfour} to say that you want to use @code{arcfour} as the encryption
algorithm, the connection will either end up using @code{arcfour}, or
algorithm negotiation will fail because the peer doesn't support
@code{arcfour}.

@multitable @columnfractions 0.1 0.2 0.2 0.5
@item Option
  @tab Algorithm type @tab Default @tab
@item @option{-z} @tab Data compression
  @tab @code{none}, @code{zlib}

  @tab The default preference list supports zlib compression, but
prefers not to use it. 

@item @option{-c} @tab Encryption
  @tab @code{aes256-cbs}, @code{3dec-cbc}, @code{blowfish-cbc}, @code{arcfour}

  @tab The default encryption algorithm is aes256. The default list
includes only quite old and well studied algorithms. There is a special
algorithm name @code{all} to enable all supported encryption algorithms
(except @code{none}).

@item @option{-m} @tab Message Authentication
  @tab @code{hmac-sha1}, @code{hmac-md5}

  @tab Both supported message authentication algorithms are of the
@acronym{HMAC} family.
@end multitable

As a special case, @option{-z} with no argument changes the compression
algorithm list to @code{zlib}, @code{none}, which means that you want to
use @code{zlib} if the other end supports it. This is different from
@option{-zzlib} which causes the negotiation to fail if the other end
doesn't support @code{zlib}. A somewhat unobvious consequence of
@option{-z} having an @emph{optional} argument is that if you provide an
argument, it must follow directly after the option letter, no spaces
allowed. 


@node Hostauth options, Userauth options, Algorithm options, Invoking lsh
@comment  node-name,  next,  previous,  up
@section Host authentication options

As described earlier (@pxref{Threats}), proper authentication of the
remote host is crucial to protect the connection against
man-in-the-middle attacks. By default, @command{lsh} verifies the server's
claimed host key against the @dfn{Access Control Lists} in
@file{~/.lsh/host-acls}. If the remote host cannot be authenticated,
the connection is dropped.

The options that change this behaviour are

@table @option
@item --host-db
Specifies the location of the @acronym{ACL} file.

@item --sloppy-host-authentication
Tell @command{lsh} not to drop the connection if the server's key can not
be authenticated. Instead, it displays the fingerprint of the key, and
asks if it is trusted. The received key is also appended to the file
@file{~/.lsh/captured_keys}. If run in quiet mode, @samp{lsh -q
--sloppy-host-authentication}, @command{lsh} connects to any host, no
questions asked.

@item --strict-host-authentication
Disable sloppy operation (this is the default behaviour).

@item --capture-to
Use some other file than @file{~/.lsh/captured_keys}. For example,

@example
lsh --sloppy-host-authentication --capture-to ~/.lsh/host-acls
@end example

@noindent
makes @command{lsh} behave more like the @command{ssh} program.

@item --srp-keyexchange
Try using @acronym{SRP} for keyexchange and mutual authentication.

@end table

@node Userauth options, Action options, Hostauth options, Invoking lsh
@comment  node-name,  next,  previous,  up
@section User authentication options

@table @option

@item -l
Provide a name to use when logging in. By default, the value of the
@env{LOGNAME} environment variable is used.

@item -i
Try the keys from this file to log in. By default, @command{lsh} uses
@file{~/.lsh/identity}, if it exists. It ought to be possible to use
several @option{-i} options to use more than one file, but that is
currently not implemented.

@item --no-publickey
Don't attempt to log in using public key authentication.

@end table

@node Action options, Verbosity options, Userauth options, Invoking lsh
@comment  node-name,  next,  previous,  up
@section Action options

There are many things @command{lsh} can do once you are logged in. There
are two types of options that control this: @dfn{actions} and
@dfn{action modifiers}. For short options, actions use uppercase letters
and modifiers use lowercase.

For each modifier @option{--foo} there's also a negated form
@option{--no-foo}. Options can also be negated by preceding it with the
special option @option{-n}. This is mainly useful for negating short
options. For instance, use @option{-nt} to tell @command{lsh} not to
request a remote pseudo terminal. Each modifier and its negation can be
used several times on the command line. For each action, the latest
previous modifier of each pair apply.

First, the actions:

@table @option

@item -L
Requests forwarding of a local port. This option takes a mandatory
argument of the form
@var{listen-port}:@var{target-host}:@var{target-port}. This option tells
@command{lsh} to listen on @var{listen-port} on the local machine. When
someone conects to that port, @command{lsh} asks the remote server to open
a connection to @var{target-port} on @var{target-host}, and if it
succeeds, the two connections are joined together through an the
@command{lsh} connection. Both port numbers should be given in decimal.

@item -R
Requests forwarding of a remote port. It takes one mandatory argument,
just like @option{-L}. But in this case @command{lsh} asks the
@emph{remote} server to listen on @var{listen-port}. When someone
connects to the remote hosts, the server will inform the local
@command{lsh}. The local @command{lsh} then connects to @var{target-port} on
@var{target-host}.

@item -D
Requests SOCKS-style forwarding. It takes one optional argument, the
port number to use for the SOCKS proxy (default is 1080). Other
applications can then use socks version 4 or version 5, to open
outgoing connections which are forwarded via the SSH connection. Note
that for short options the port number must be in the same argument if given
(i.e. @samp{-D1080} is correct, @samp{-D 1080} is not).
 
@item -E
This option takes one mandatory argument, which is a command line to be
executed on the remote machine.

@item -S
Start an interactive shell on the remote machine. 

@item -G
Open a gateway on the local machine. A gateway is a local socket,
located under /tmp, that can be used for controlling and using the ssh
connection. It is protected using the ordinary file permissions.

@item -N
This is a no-operation action. It inhibits the default action, which is
to start an interactive shell on the remote machine. It is useful if you
want to set up a few forwarded tunnels or a gateway, and nothing more.

@item -B
Put the client into the background after key exchange and
user authentication. Implies @option{-N}

@item --subsystem
Specifies a subsystem to connect to, implies @option{--no-pty}. Example usage:
@samp{--subsystem=sftp}

@end table

If there are trailing arguments after the name of the remote system,
this is equivalent to a @option{-E} option, with a command string
constructed by catenating all the remaining arguments, separated by
spaces. This implies that the arguments are usually expanded first by
the local shell, and then the resulting command string is interpreted
again by the remote system.

If there are no trailing arguments after the name of the remote system,
and the @option{-N} option is not given, the default action is to start
a shell on the remote machine. I.e. this is equivalent to the
@option{-S} option.

There are a few supported modifiers:

@table @option

@item -t
Request a pseudo terminal. @command{lsh} asks the remote system to allocate
a pseudo terminal. If it succeeds, the local terminal is set to raw
mode. The default behaviour is to request a pty if and only if the
local @command{lsh} process has a controlling terminal. This modifier
applies to actions that create remote processes, i.e. @option{-E} and
@option{-S}, as well as the default actions.

Currently, this option is ignored if there is no local terminal.

@item -x
Request @acronym{X} forwarding. Applies to the @option{-E} and
@option{-S} and the default actions.

@item --stdin
Redirect the stdin of a remote process from a given, local, file.
Default is to use @command{lsh}'s stdin for the first process, and
@file{/dev/null} for the rest. This option applies to the @option{-E}
and @option{-S} options as well as to the default actions. The option
applies to only one process; as soon as it is used it is reset to the
default.

@item --stdout
Redirect the stdout of a remote process to a given, local, file. Default
is to use @command{lsh}'s stdout. Like @option{--stdin}, it is reset
after it is used.

@item --stderr
Redirect the stdout of a remote process to a given, local, file.
Analogous to the @option{--stdout} option.

@item --detach
Detach from terminal at session end.

@item --write-pid
Applies to @option{-E}. Write PID of backgrounded process to stdout.



@item -e
Set the escape character (use ``none'') to disable. Default is ``~''
if a tty is allocated and ``none'' otherwise.



@item -g
Remote peers, aka global forwarding. This option applies to the
forwarding actions, i.e. @option{-L}, @option{-R} and @option{-D}. By
default, only connections to the loopback interface, ip 127.0.0.1, are
forwarded. This implies that only processes on the same machine can use
the forwarded tunnel directly. If the -g modifier is in effect, the
forwarding party will listen on @emph{all} network interfaces.

@end table

@node Verbosity options,  , Action options, Invoking lsh
@comment  node-name,  next,  previous,  up
@section Verbosity options

These options determines what messages @command{lsh} writes on
its stderr.

@table @option

@item -q
Quiet mode. Disables all messages and all questions, except password
prompts and fatal internal errors.

@item -v
Verbose mode. Makes @command{lsh} a little more verbose. The intention is
to provide information that is useful for ordinary trouble shooting,
and makes sense also to those not familiar with @command{lsh} internals.

@item --trace
Trace mode. Prints some internal information to aid tracking
@command{lsh}'s flow of control.

@item --debug.
Debug mode. Dumps @emph{a lot} of information, including dumps of all
sent and received packets. It tries to avoid dumping highly sensitive data,
such as private keys and the contents of @code{SSH_MSG_USERAUTH_REQUEST}
messages, but you should still use it with care.

@item --log-file
This option redirects all messages to a file. Takes one mandatory
argument: The name of that file.

@end table

Note that all these options are orthogonal. If you use @option{--trace},
you usually want to add @option{-v} as well; @option{--trace} does not
do that automatically.

@node Invoking lshg, Invoking lshd, Invoking lsh, Top
@comment  node-name,  next,  previous,  up
@chapter Invoking @command{lshg}
@anchor{lshg-usage}

You use @command{lshg} to login to a remote machine to which you have
previously used @command{lsh} to set up a gateway (@pxref{Action
options}). Its usage is very similar to that of @command{lsh}
(@pxref{Invoking lsh}), except that some options are not available.

Basic usage is

@samp{lshg [-l @var{username}] @var{host}}

which attempts to connect to the gateway that should previously have
been established by running @samp{lsh [-l @var{username}] -G @var{host}})

The @var{username} and @var{host} are used to locate the gateway. The
default value for @var{username} is determined in the same way as for
@command{lsh} (@pxref{Invoking lsh}).

As @command{lshg} uses almost the same options as @command{lsh}
(@pxref{Invoking lsh}), only options that are not available or have
a different meaning in @command{lshg} are listed here.

The algorithm options (@pxref{Algorithm options}) as well as most of
the userauth (@pxref{Userauth options}) and hostauth (@pxref{Hostauth
options}) are not available in @command{lshg} as they are only used by
session setup, which is already handled by @command{lsh}.

Due to technical reasons, @acronym{X11}-forwarding cannot be performed by
@command{lshg}, thus the @option{--x11-forward} option (@pxref{Action options}) is not
available.

To summarize, these are the options that are new, not available or
that have different meanings:

@table @option
@item -G
For @command{lsh} @option{-G} requests a gateway to be set up. For
@command{lshg} it means that if no usable gateway is found
@command{lsh} should be launched with the same arguments instead. 

@item --send-debug
Not available in @command{lsh}. Sends a @samp{debug} message to the remote machine.

@item --send-ignore
Not available in @command{lsh}.  Sends a @samp{ignore} message to the remote machine.

@item -x
(@option{--x11-forward}) Not available in @command{lshg}.

@item -c
(@option{--crypto}) Not available in @command{lshg}.

@item -z
(@option{--compression}) Not available in @command{lshg}.

@item -m
(@option{--mac}) Not available in @command{lshg}.

@item --hostkey-algorithm
Not available in @command{lshg}.

@item --capture-to
Not available in @command{lshg}.

@item --strict-host-authentication
Not available in @command{lshg}.

@item --sloppy-host-authentication
Not available in @command{lshg}.

@item --host-db
Not available in @command{lshg}.

@item --publickey
Not available in @command{lshg}.

@item --no-publickey
Not available in @command{lshg}.

@item --dh-keyexchange
Not available in @command{lshg}.

@item --no-dh-keyexchange
Not available in @command{lshg}.

@item --srp-keyexchange
Not available in @command{lshg}.

@item --no-srp-keyexchange
Not available in @command{lshg}.

@item -i
@option{--identity} Not available in @command{lshg}.


@end table

@node Invoking lshd, Files and environment variables, Invoking lshg, Top
@comment  node-name,  next,  previous,  up
@chapter Invoking @command{lshd}
@anchor{lshd-usage}

@command{lshd} is a server that accepts connections from clients
speaking the Secure Shell Protocol. It is usually started automatically
when the systems boots, and runs with root privileges. However, it is
also possible to start @command{lshd} manually, and with user
privileges.

There are currently no configuration files. Instead, command line options
are used to tell @command{lshd} what to do. Many options have @option{--foo}
and @option{--no-foo} variants. Options specifying the default behaviour
are not listed here.

Some of the options are the shared with @command{lsh}. In particular, see
@ref{Algorithm options} and @ref{Verbosity options}.

Options specific to the @command{lshd} server are:

@table @option

@item -p
Port to listen to. The mandatory argument is a decimal port number or a
service name. Default is "ssh", usually port 22.

It should also be possible to use several -p options as a convenient way
to make lshd listen on several ports on each specified (or default)
interface, but that is not yet implemented.

Note that if you use both @option{-p} and @option{--interface}, the
order matters.

@item --interface
Network interface to listen on. By default, @command{lshd} listens on all
interfaces. An interface can be specified as a DNS name, a literal IPv4
address, or a literal IPv6 address enclosed in square brackets. It can
optionally be followed by a colon and a port number or service name. If
no port number or service is specified, the default or the value from a
@emph{preceding} @option{-p} is used.

Some examples: @code{--interface=localhost},
@code{--interface=1.2.3.4:443}, @code{--interface=[aaaa::bbbb]:4711}. To
make @command{lshd} listen on several ports and interfaces at the same
time, just use several @option{--interface} options on the command line.

@item -h
Location of the server's private key file. By default,
@file{/etc/lsh_host_key}.

@item --daemonic
Enables daemonic mode. @command{lshd} forks into the background,
redirects its stdio file descriptors to @file{/dev/null}, changes its
working directory to @file{/}, and redirects any diagnostic or debugging
messages via syslog.

@command{lshd} should be able to deal with the environment it inherits
if it is started by @command{init} or @command{inetd}, but this is not
really tested.

@item --pid-file
Creates a locked pid file, to make it easier to write start and stop
scripts for @command{lshd}. The mandatory argument provides the filename.
This option is enabled by default when operating in daemonic mode, and
the default filename is @file{/var/run/lshd.pid}.

@item --no-syslog
Disable the use of the syslog facility. Makes sense only together with
@option{--daemonic}

@item --enable-core
By default, @command{lshd} disables core dumps, to avoid leaking sensitive
information. This option changes that behaviour, and allows @command{lshd}
to dump core on fatal errors.

@item --no-password
Disable the "password" user authentication mechanism. 

@item --no-publickey
Disable the "publickey" user authentication mechanism.

@item --root-login
Enable root login. By default, root can not log in using @command{lshd}.

@item --login-auth-mode
This option is highly experimental. Bypass @option{lshd}'s user
authentication, and allow users to spawn their login-shell without any
authentication. Usually combined with @option{--login-shell}, to set the
login shell to a program that performce password authentication.

@item --kerberos-passwords
Verify passwords against the kerberos database. This is implemented
using the @command{lsh-krb-checkpw} helper program. Note that this does
@emph{not} use the Kerberos infrastructure in the Right Way. Experimental.

@item --password-helper
Tells @command{lshd} to use a helper program for verifying passwords.
This is a generalization of @option{--kerberos-passwords}, and it could
be used for verifying passwords against any password database. See the
source files @file{lsh-krb-checkpw.c} and @file{unix_user.c} for
details. 

@item --login-shell
Use the specified program as the login shell for all users, overriding
the login shell in the passwd database.

@item --srp-keyexchange
Enable @acronym{SRP} keyexchange and user authentication.

@item --no-pty-support
Disable support for pseudo terminals.

@item --no-tcp-forward
Disable support for tcp forwarding, in both directions.

@item --subsystems
Specifies a list of subsystems and corresponding
programs. 
Example usage: @samp{--subsystems=sftp=/usr/sbin/sftp-server,foosystem=/usr/bin/foo}

@end table

@node Files and environment variables, Terminology, Invoking lshd, Top
@comment  node-name,  next,  previous,  up
@chapter Files and environment variables

This chapters describes all files and all environment variables that
are used by @command{lsh}, @command{lshd}, and related programs.

There are a few environment variables that modifies the behaviour of
the @command{lsh} programs. And there are also a handful of variables
that are setup by @command{lshd} when starting user processes.

@table @env
@item DISPLAY
When @acronym{X}-forwarding is enabled, @env{DISPLAY} specifies the
local display. Used by @command{lsh}.

@item HOME
User's home directory. Determines where client programs looks for the
@file{~/.lsh} directory. When @command{lshd} starts a user program, it
sets @env{HOME} from the value in the @file{/etc/passwd} file, except
if @command{lshd} is running as an ordinary user process. In the
latter case, the new process inherits @command{lsh}'s own value of
@env{HOME}.
 
@item LOGNAME
The user's log in name. Used as the default name for logging into
remote systems. Set by @command{lshd} when starting new processes.

@item LSH_YARROW_SEED_FILE
If set, it points out the location of the seed-file for the randomness
generator. Recognized both by @command{lshd} and the client programs.

@item LSHFLAGS
If set, lsh will parse any options as had they been given on the
command line.

@item LSHGFLAGS
If set, lshg will parse any options as had they been given on the
command line.

@item POSIXLY_CORRECT
Affects the command line parsing of programs which by default accept
options mixed with arguments.

@item SEXP_CONV
The location of the @command{sexp-conv} program. If not set, the default
@file{$prefix/bin/sexp-conv} is used.

@item SSH_CLIENT
This variable may be set by lshd for established sessions. If it is set
it consists of three parts separated by whitespace, the first part
contains the address of the connecting client. The second part
contains the tcp port used on the connecting client and the third part
contains the tcp port used on the server.

@item SSH_TTY
This variable may be set by lshd for established sessions. If it is set
it is the name of the tty allocated.

@item SHELL
User's login shell. When @command{lshd} starts a user process, it sets
@env{SHELL} to the value in @file{/etc/passwd}, unless overridden by
the @option{--login-shell} command line option.

@item TERM
The type of the local terminal. If the client requests a pty for a
remote process, the value of @env{TERM} is transferred from client to
server.

@item TMPDIR
Determines where the unix socket used by @command{lshg} is located in
the filesystem.

@item TZ
Time zone. Processes started by @command{lshd} inherit the value of
this variable from the server process.

@c used by xlib @item XAUTHORITY
@end table

Files used by the lsh client, stored in the @file{~/lsh} directory:

@table @file
@item captured_keys
Keys for remote hosts, saved when running @samp{lsh
--sloppy-host-authentication}. Or more precicely, each key is stored
together with an as SPKI (Simple Public Key Intrastructure) ACL:s
(Access Control Lists).

@item identity
Your private key file. Usually created by @samp{lsh-keygen |
lsh-writekey}. Read by @command{lsh}. Should be kept secret.

@item identity.pub
The corresponding public key. You can copy this file to other systems
in order to authorize the private key to login (@pxref{Converting
keys}). 

@item host-acls
Host keys (or more precisely, ACL:s) that lsh considers authentic.
Entries have the same format as in @file{captured_keys}.

@item yarrow-seed-file
The seed file for the randomness generator. Should be kept secret.

@end table

Files used by @command{lshd}, some of which are read from user home
directories:

@table @file
@item /etc/lsh_host_key
The server's private host key.

@item /etc/lsh_host_key.pub
The corresponding public key.

@item /var/spool/lsh/yarrow-seed-file
The seed-file for @command{lshd}'s randomness generator.

@item ~/.lsh/authorized_keys
This is a directory that keeps a ``database'' of keys authorized for
login. With the current implementation, a key is authorized for login
if and only if this directory contains a file with a name which is the
SHA1 hash of the key. The usual way to create files is by running the
script @command{lsh-authorize}.

@item ~/.lsh/srp-verifier
If you use the experimental support for @acronym{SRP} (@pxref{srp}),
the server reads a user's @acronym{SRP} verifier from this file.
@end table


@node Terminology, Concept Index, Files and environment variables, Top
@comment  node-name,  next,  previous,  up
@chapter Terminology

@node    Concept Index,  , Terminology, Top
@comment  node-name,  next,  previous,  up
@unnumbered Concept Index

@printindex cp
     
@bye
